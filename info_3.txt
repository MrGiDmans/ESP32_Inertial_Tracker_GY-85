2.4 Калибровка гироскопа и магнитометра

В данном разделе рассмотрены методы и реализация калибровки инерциальных датчиков для повышения точности измерений ориентации.

2.4.1 Калибровка гироскопа

Принцип работы:
- Компенсация постоянного смещения (bias) в показаниях угловых скоростей
- Сбор 500 сэмплов в неподвижном состоянии
- Расчет средних значений смещений по каждой оси

Процесс калибровки:
1. Накопление данных:
   - Чтение сырых данных гироскопа
   - Преобразование в градусы/секунду
   - Суммирование показаний по осям

2. Расчет смещений:
   - Вычисление средних значений
   - Сохранение в EEPROM
   - Отправка подтверждения

2.4.2 Калибровка магнитометра

Принцип работы:
- Компенсация магнитных искажений
- Поиск минимальных и максимальных значений
- Расчет смещений как средних значений

Процесс калибровки:
1. Сбор данных:
   - Чтение магнитного поля
   - Обновление min/max значений
   - Продолжительность: 10 секунд

2. Расчет смещений:
   - Среднее между min и max
   - Сохранение в EEPROM
   - Отправка подтверждения

2.4.3 Хранение калибровочных данных

Структура хранения:
- Размер: 26 байт
- Магическое число: 0xA5A5
- Смещения гироскопа (3 × float)
- Смещения магнитометра (3 × float)

Функции:
1. saveCalibration():
   - Проверка размера EEPROM
   - Запись магического числа
   - Запись смещений
   - Подтверждение записи

2. loadCalibration():
   - Проверка магического числа
   - Загрузка смещений
   - Сброс при ошибке

2.4.4 Псевдокод процесса калибровки

1. Калибровка гироскопа:
   - Сбор 500 сэмплов
   - Расчет средних значений
   - Сохранение смещений

2. Калибровка магнитометра:
   - Сбор данных 10 секунд
   - Поиск min/max значений
   - Расчет смещений

3. Сохранение данных:
   - Проверка EEPROM
   - Запись параметров
   - Подтверждение

2.4.5 Дополнительные аспекты реализации

1. Семафоры и мьютексы:
   - dataMutex: защищает доступ к данным датчиков
     * Захватывается перед чтением/записью sensorData
     * Предотвращает конфликты между задачами чтения и отправки
     * Пример использования:
       xSemaphoreTake(dataMutex, portMAX_DELAY);
       // работа с данными
       xSemaphoreGive(dataMutex);

   - cmdMutex: защищает обработку команд
     * Захватывается при обработке входящих команд
     * Предотвращает одновременную обработку нескольких команд
     * Обеспечивает атомарность операций с флагами калибровки

2. MAGIC_NUMBER (0xA5A5):
   - Назначение: проверка целостности данных в EEPROM
   - Расположение: первые 2 байта EEPROM
   - Использование:
     * При сохранении: записывается перед калибровочными данными
     * При загрузке: проверяется на соответствие
     * Если не совпадает: данные считаются недействительными
   - Защита от:
     * Первого запуска
     * Повреждения данных
     * Неинициализированной памяти

3. Получение значений ориентации:

   а) Расчет углов по акселерометру:
      - Roll = atan2(accY, accZ) * RAD_TO_DEG
      - Pitch = atan2(-accX, sqrt(accY² + accZ²)) * RAD_TO_DEG
      - Точность: высокая в статике, низкая при движении

   б) Расчет угла по магнитометру:
      - Yaw = atan2(magY, magX) * RAD_TO_DEG
      - Требует компенсации наклона:
        * Xh = magX * cos(pitch) + magZ * sin(pitch)
        * Yh = magX * sin(roll) * sin(pitch) + 
               magY * cos(roll) - 
               magZ * sin(roll) * cos(pitch)
      - Точность: зависит от калибровки

   в) Интегрирование гироскопа:
      - Углы = предыдущие_углы + угловая_скорость * dt
      - Накопление ошибки со временем
      - Высокая точность в динамике

4. Комплементарный фильтр:

   а) Принцип работы:
      - Комбинирование данных акселерометра и гироскопа
      - Коэффициент ALPHA = 0.96 определяет веса:
        * Гироскоп: ALPHA
        * Акселерометр: (1 - ALPHA)

   б) Формулы фильтрации:
      - Roll = ALPHA * (roll + gyroX * dt) + 
               (1 - ALPHA) * roll_acc
      - Pitch = ALPHA * (pitch + gyroY * dt) + 
                (1 - ALPHA) * pitch_acc
      - Yaw = interpolateAngle(yaw, magYaw, 1.0 - ALPHA)

   в) Особенности реализации:
      - Нормализация углов в диапазоны [-180,180] и [0,360]
      - Обработка переполнения через 0/360 градусов
      - Компенсация наклона для магнитометра

   г) Точный режим (precise_mode):
      - Отключение инерциальной составляющей
      - Использование только акселерометра и магнитометра
      - Применяется для статических измерений

5. Взаимодействие компонентов:
   - Задача чтения датчиков обновляет данные
   - Комплементарный фильтр обрабатывает данные
   - Задача отправки передает результаты
   - Семафоры обеспечивают синхронизацию
   - Калибровка улучшает точность измерений

2.4.6 Константы и преобразования

1. RAD_TO_DEG (180/π ≈ 57.29577951308232):
   - Назначение: преобразование радиан в градусы
   - Использование: умножение углов в радианах для получения градусов
   - Пример: atan2(accY, accZ) * RAD_TO_DEG
   - Обратное преобразование: DEG_TO_RAD = π/180

2. Применение в расчетах:
   - Функции atan2() возвращают результат в радианах
   - Умножение на RAD_TO_DEG переводит в градусы
   - Необходимо для:
     * Расчетов углов по акселерометру
     * Расчетов углов по магнитометру
     * Нормализации углов в градусах

2.4.7 Математические функции и параметры

1. atan2(y, x):
   - Назначение: вычисление арктангенса с учетом квадранта
   - Отличие от atan: учитывает знаки x и y
   - Диапазон результата: [-π, π] радиан
   - Использование в коде:
     * Roll = atan2(accY, accZ) - угол крена
     * Pitch = atan2(-accX, sqrt(accY² + accZ²)) - угол тангажа
     * Yaw = atan2(magY, magX) - угол курса
   - Преимущества:
     * Корректная работа во всех квадрантах
     * Автоматическая обработка деления на ноль
     * Точное определение направления

2. dt (delta time):
   - Назначение: интервал времени между измерениями
   - Единица измерения: секунды
   - Расчет: dt = (текущее_время - предыдущее_время) / 1000.0
   - Использование в коде:
     * Интегрирование угловых скоростей
     * Комплементарный фильтр
     * Нормализация частоты измерений
   - Важность:
     * Влияет на точность интегрирования
     * Определяет частоту обновления данных
     * Используется для компенсации задержек

2.4.8 Создание задач FreeRTOS

1. Функция xTaskCreatePinnedToCore:
   - Назначение: создание задачи с привязкой к конкретному ядру
   - Параметры:
     * pvTaskCode: указатель на функцию задачи
     * pcName: имя задачи (для отладки)
     * usStackDepth: размер стека в словах
     * pvParameters: параметры для задачи
     * uxPriority: приоритет задачи (0-24)
     * pvCreatedTask: указатель на хендл задачи
     * xCoreID: номер ядра (0 или 1)

2. Примеры использования в коде:
   - readSensorsTask:
     * Ядро: 0
     * Приоритет: 2
     * Размер стека: 4096
     * Назначение: чтение датчиков

   - sendDataTask:
     * Ядро: 1
     * Приоритет: 1
     * Размер стека: 4096
     * Назначение: отправка данных

   - handleCommandsTask:
     * Ядро: 1
     * Приоритет: 1
     * Размер стека: 4096
     * Назначение: обработка команд

3. Распределение задач по ядрам:
   - Ядро 0:
     * Высокоприоритетные задачи
     * Критичные по времени
     * Чтение датчиков

   - Ядро 1:
     * Задачи с меньшим приоритетом
     * Сетевое взаимодействие
     * Обработка команд

4. Приоритеты задач:
   - 0: самый низкий
   - 24: самый высокий
   - Влияет на порядок выполнения
   - Определяет время отклика

2.4.9 Прерывания и оптимизация

1. Текущая реализация:
   - Использование многозадачной архитектуры FreeRTOS
   - Отсутствие явных прерываний
   - Планировщик задач FreeRTOS

2. Оптимизация в текущей реализации:

   а) Распределение задач по ядрам:
      - Ядро 0: высокоприоритетные задачи чтения датчиков
      - Ядро 1: задачи сетевого взаимодействия
      - Преимущества:
        * Параллельное выполнение
        * Уменьшение задержек
        * Эффективное использование ресурсов

   б) Синхронизация через семафоры:
      - dataMutex: защита данных датчиков
      - cmdMutex: защита обработки команд
      - Преимущества:
        * Предотвращение конфликтов
        * Атомарность операций
        * Безопасный доступ к ресурсам

   в) Оптимизация частоты:
      - SAMPLE_RATE = 100 Гц для датчиков
      - SEND_RATE = 50 Гц для отправки
      - Преимущества:
        * Баланс между точностью и нагрузкой
        * Эффективное использование пропускной способности
        * Стабильная работа системы

   г) Управление памятью:
      - Фиксированные размеры буферов
      - Оптимизированные структуры данных
      - Минимальное использование динамической памяти
      - Преимущества:
        * Предсказуемое поведение
        * Отсутствие утечек памяти
        * Эффективное использование ресурсов

3. Возможные улучшения с прерываниями:

   а) Прерывания для датчиков:
      - Обработка данных по готовности
      - Уменьшение задержек
      - Более точная синхронизация

   б) Прерывания для сетевого взаимодействия:
      - Быстрая обработка входящих пакетов
      - Уменьшение задержек передачи
      - Улучшение отзывчивости системы

   в) DMA для передачи данных:
      - Освобождение CPU от операций ввода/вывода
      - Параллельная обработка данных
      - Увеличение производительности

4. Рекомендации по оптимизации:

   а) Добавление прерываний:
      - Для критических операций чтения датчиков
      - Для обработки внешних событий
      - Для синхронизации с внешними устройствами

   б) Оптимизация памяти:
      - Уменьшение размеров стеков задач
      - Кэширование часто используемых данных
      - Оптимизация структур данных

   в) Улучшение производительности:
      - Использование DMA
      - Оптимизация алгоритмов фильтрации
      - Улучшение сетевого протокола

5. Волатильные переменные:
   - Использование volatile для флагов:
     * calibrate_gyro_flag
     * calibrate_mag_flag
     * precise_mode
   - Назначение:
     * Предотвращение оптимизации компилятором
     * Гарантия актуальности данных
     * Безопасный доступ из разных задач
